---
title: "R Notebook"
output: html_notebook
---

```{r}
library(affycoretools)
library(affy)

files_mix_TFEC <- list.files(pattern = "CEL.gz")
celfiles_mix_TFEC <- lapply(files_mix_TFEC, function(x) ReadAffy(filenames = x))
table(sapply(celfiles_mix_TFEC, annotation))
hgu133a_mix_TFEC <- ReadAffy(filenames = celfiles_mix_TFEC$hgu133a)
```


```{r}
#BiocManager::install("gcrma")
#memory.limit()
#memory.limit(size=40000)
library(gcrma)
eset_TFEC <- gcrma(hgu133a_mix_TFEC)
exprs_TFEC <- exprs(eset_TFEC)
write.csv(exprs_TFEC, "exprs_gcrma_TFEC.csv")
```

```{r}
library(hgu133plus2.db)
celfiles.filtered_TFEC <- nsFilter(eset_TFEC, require.entrez=TRUE, remove.dupEntrez=TRUE)
celfiles.filtered_TFEC$eset
celfiles.filtered_TFEC$filter.log

ans_TFEC <- nsFilter(eset_TFEC, var.filter=TRUE)
ans_TFEC$eset
write.csv(exprs(ans_TFEC$eset), "eset.gcrma_TFEC.csv")
```


```{r}
library(ggrepel)
library(dplyr)
library(stats)

#Differential Expression

clinical_data_TFEC <- read.csv(file = 'clinical_TFEC.csv')

library(limma)
design_TFEC <- model.matrix(~0+clinical_data_TFEC$chemo_response)
design_TFEC

## the column names are a bit ugly, so we will rename
colnames(design_TFEC) <- c("pCR","RD")
fit_TFEC <- lmFit(ans_TFEC$eset, design_TFEC)
head(fit_TFEC$coefficients)

contrasts_TFEC <- makeContrasts(pCR - RD, levels=design_TFEC)
fit2_TFEC<- contrasts.fit(fit_TFEC, contrasts_TFEC)
fit2_TFEC <- eBayes(fit2_TFEC)
Toptable_TFEC <- topTable(fit2_TFEC, coef=1, n = "inf" , adjust = "fdr")
Toptable_TFEC$log2FC <- logratio2foldchange(Toptable_TFEC$logFC, base = 2)
Toptable_TFEC

FDR_TFEC <- p.adjust(Toptable_TFEC$P.Value, method = "fdr", n = length(Toptable_TFEC$P.Value))
FDR_TFEC <- as.data.frame(FDR_TFEC)
FDR_TFEC

Results.Toptable_TFEC <- cbind(Toptable_TFEC, FDR_TFEC)
Results.Toptable_TFEC
```

```{r}
library(hgu133a.db)
library(annotate)
gene.symbols_TFEC<- getSYMBOL(row.names(Results.Toptable_TFEC), "hgu133a")
results_TFEC<- cbind(Results.Toptable_TFEC, gene.symbols_TFEC)
results_TFEC
write.csv(results_TFEC, "results_output_TFEC_all_genes.csv")
```

```{r}
data_DEGS_TFEC <- read.csv(file = 'results_output_TFEC_all_genes.csv', row.names = 1)

library(EnhancedVolcano)

EnhancedVolcano(data_DEGS_TFEC,
    lab = rownames(data_DEGS_TFEC),
    x = 'logFC',
    y = 'P.Value',
    xlim = c(-4.6, 4.6),
    ylim = c(0, 5),
    title = 'pCR versus RD TFEC for TNBC patients',
    pCutoff = 0.05,
    FCcutoff = 0.5,
    labFace = 'bold')
```

```{r}
data_total_TFEC <- read.csv(file = 'data_total_TFEC.csv', row.names = 1)

complete_data_TFEC  <-data_total_TFEC[sample(nrow(data_total_TFEC)),]

#Divide the data into training and validation set

library(caret)
set.seed(123) # Ensure reproducibility

# Create 10 folds. This will create a list where each element is a vector of row indices for the training set in each fold.
folds <- createFolds(complete_data_TFEC$chemo_response, k = 10, list = TRUE, returnTrain = TRUE)

# To see how to use these folds, let's loop through them and split the data into training and validation sets for each fold.
for(i in 1:length(folds)) {
  # Training data for the i-th fold
  TFEC_train_indices <- folds[[i]]
  TFEC_train_set <- complete_data_TFEC[TFEC_train_indices, ]
  
  # Validation data for the i-th fold. It's the set difference between all indices and the training indices.
  TFEC_validation_indices <- setdiff(1:nrow(complete_data_TFEC), TFEC_train_indices)
  TFEC_validation_set <- complete_data_TFEC[TFEC_validation_indices, ]
  # At this point, you would proceed to train your model on train_set and validate it on validation_set
  # For example:
  # model <- train(YourModel, data = train_set, ...)
  # predictions <- predict(model, newdata = validation_set)
  # accuracy <- sum(predictions == validation_set$target) / nrow(validation_set)
  
  # Print out the sizes of each set for verification
  cat(sprintf("Fold %d: Training set has %d rows, Validation set has %d rows\n", i, nrow(TFEC_train_set), nrow(TFEC_validation_set)))
}

write.csv(TFEC_train_set, "TFEC_train_set.csv" )
write.csv(TFEC_validation_set, "TFEC_validation_set.csv" )

dim(TFEC_train_set)
TFEC_train_set$chemo_response
dim(TFEC_validation_set)
TFEC_validation_set$chemo_response
```



```{r}
TFEC_train_set_data  <-TFEC_train_set[sample(nrow(TFEC_train_set)),]
TFEC_train_set_data$chemo_response <- as.factor(TFEC_train_set_data$chemo_response )

# Assuming 'data' is your DataFrame
#features <- data_MMR_CRC[, -ncol(data_MMR_CRC)] # Remove the class column to get only the features
#class <- data_MMR_CRC[, ncol(data_MMR_CRC)] # Get only the class column

TFEC_target_column_name <- "chemo_response"
TFEC_target_column_index <- which(names(TFEC_train_set_data) == TFEC_target_column_name)

# Splitting the data into x (features) and y (target variable)
x1 <- TFEC_train_set_data[, -TFEC_target_column_index] # All columns except the target
y1 <- TFEC_train_set_data[, TFEC_target_column_index]  # Only the target column

# Apply upSample
up_sampled_TFEC <- upSample(x = x1, y = y1)

# The `upSample` function returns a list with two elements: x and y.
# `x` is a dataframe of the oversampled features, and `y` is the oversampled target variable.

# Combine x and y back into a dataframe
oversampled_data_TFEC_train <- data.frame(up_sampled_TFEC)

# Check the first few rows of the balanced dataset
head(oversampled_data_TFEC_train)

# Check the balance of the target variable after oversampling
table(oversampled_data_TFEC_train$Class)
#write.csv(oversampled_data_TFEC_train, "oversampled_data_TFEC_train.csv" )
```
```{r}
# Load necessary libraries
library(ggplot2)

# Assuming 'data' is your dataframe and it contains 'MMR_status' column
# Let's first remove the MMR_status column to perform PCA on just the molecular features

train_data_TFEC <- read.csv(file = 'oversampled_data_TFEC_train.csv', row.names = 1)

train_data_TFEC$Class <- as.factor(train_data_TFEC$Class)

features <- train_data_TFEC[, -which(names(train_data_TFEC) == "Class")]

# Perform PCA
pca_result <- prcomp(features, center = TRUE, scale. = TRUE)

library(mixOmics)

# Assuming 'data' has samples as rows and features as columns, and 'MMR_status' as a factor
plsda_result <- plsda(features, train_data_TFEC$Class)

# Plot the results
plotIndiv(plsda_result, ind.names = FALSE, legend = TRUE, title = 'PCA//TFEC Training Set')
```



```{r}
TFEC_validation_set_data  <-TFEC_validation_set[sample(nrow(TFEC_validation_set)),]
TFEC_validation_set_data$chemo_response <- as.factor(TFEC_validation_set_data$chemo_response )

# Assuming 'data' is your DataFrame
#features <- data_MMR_CRC[, -ncol(data_MMR_CRC)] # Remove the class column to get only the features
#class <- data_MMR_CRC[, ncol(data_MMR_CRC)] # Get only the class column

TFEC_target_column_name_2 <- "chemo_response"
TFEC_target_column_index_2 <- which(names(TFEC_validation_set_data) == TFEC_target_column_name_2)

# Splitting the data into x (features) and y (target variable)
x2 <- TFEC_validation_set_data[, -TFEC_target_column_index_2] # All columns except the target
y2 <- TFEC_validation_set_data[, TFEC_target_column_index_2]  # Only the target column

# Apply upSample
up_sampled_TFEC_2 <- upSample(x = x2, y = y2)

# The `upSample` function returns a list with two elements: x and y.
# `x` is a dataframe of the oversampled features, and `y` is the oversampled target variable.

# Combine x and y back into a dataframe
oversampled_data_TFEC_validation <- data.frame(up_sampled_TFEC_2)

# Check the first few rows of the balanced dataset
head(oversampled_data_TFEC_validation)

# Check the balance of the target variable after oversampling
table(oversampled_data_TFEC_validation$Class)
write.csv(oversampled_data_TFEC_validation, "oversampled_data_TFEC_validation.csv" )
```
```{r}
# Load necessary libraries
library(ggplot2)
oversampled_data_TFEC_validation <- read.csv(file = 'oversampled_data_TFEC_validation.csv', row.names = 1)
# Assuming 'data' is your dataframe and it contains 'MMR_status' column
# Let's first remove the MMR_status column to perform PCA on just the molecular features

oversampled_data_TFEC_validation$Class <- as.factor(oversampled_data_TFEC_validation$Class)

features <- oversampled_data_TFEC_validation[, -which(names(oversampled_data_TFEC_validation) == "Class")]

# Perform PCA
pca_result <- prcomp(features, center = TRUE, scale. = TRUE)

# Summarize PCA results
summary(pca_result)

# Plot PCA results
# First, prepare a dataframe that includes principal components and the MMR status
pca_data <- as.data.frame(pca_result$x)
pca_data$Class <- oversampled_data_TFEC_validation$Class

# Use ggplot to visualize the first two principal components
ggplot(pca_data, aes(x = PC1, y = PC2, color = Class)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of pCR and RD Samples",
       x = "Principal Component 1",
       y = "Principal Component 2",
       color = "Class")

# Optionally, explore loadings to see which features contribute most to the principal components
loadings <- pca_result$rotation

library(mixOmics)

# Assuming 'data' has samples as rows and features as columns, and 'MMR_status' as a factor
plsda_result <- plsda(features, oversampled_data_TFEC_validation$Class)

# Plot the results
plotIndiv(plsda_result, ind.names = FALSE, legend = TRUE, title = 'PCA//TFEC Validation Set')
```


```{r}
data_total_TFEC <- read.csv(file = 'data_TFEC_96.csv', row.names = 1)

TFEC_complete_data  <-data_total_TFEC[sample(nrow(data_total_TFEC)),]
TFEC_complete_data$chemo_response <- as.factor(TFEC_complete_data$chemo_response )

# Assuming 'data' is your DataFrame
#features <- data_MMR_CRC[, -ncol(data_MMR_CRC)] # Remove the class column to get only the features
#class <- data_MMR_CRC[, ncol(data_MMR_CRC)] # Get only the class column

TFEC_target_column_name1 <- "chemo_response"
TFEC_target_column_index1 <- which(names(TFEC_complete_data) == TFEC_target_column_name1)

# Splitting the data into x (features) and y (target variable)
x1 <- TFEC_complete_data[, -TFEC_target_column_index1] # All columns except the target
y1 <- TFEC_complete_data[, TFEC_target_column_index1]  # Only the target column

# Apply upSample
up_sampled_TFEC <- upSample(x = x1, y = y1)

# The `upSample` function returns a list with two elements: x and y.
# `x` is a dataframe of the oversampled features, and `y` is the oversampled target variable.

# Combine x and y back into a dataframe
oversampled_data_TFEC <- data.frame(up_sampled_TFEC)

# Check the first few rows of the balanced dataset
head(oversampled_data_TFEC)

# Check the balance of the target variable after oversampling
table(oversampled_data_TFEC$Class)
write.csv(oversampled_data_TFEC, "oversampled_data_TFEC_96.csv" )
```
```{r}
# Load necessary library
library(pheatmap)


# Load the heatmap data
data_pheatmap <- read.csv(file = 'data_pheatmap_train.csv', row.names = 1)
clinical_data_pheatmap <- read.csv(file = 'clinical_TFEC_pheatmap.csv', row.names = 1)

# Load clinical data for annotations
clinical_data_pheatmap$Class <- as.factor(clinical_data_pheatmap$Class)

# This assumes that the samples in data_for_heatmap correspond to the rows in clinical_data
ordered_columns <- order(clinical_data_pheatmap$Class)
ordered_data_for_heatmap <- data_pheatmap[, rownames(clinical_data_pheatmap)[ordered_columns]]

# Prepare annotation data for columns based on the new order
annotation_col <- data.frame(Class = clinical_data_pheatmap$Class[ordered_columns])
rownames(annotation_col) <- rownames(clinical_data_pheatmap)[ordered_columns]

# Generate a color palette for the annotation
annotation_colors <- list(Class = c(pCR = "blue", RD = "red"))

# Create the heatmap with ordered data and annotation
pheatmap(ordered_data_for_heatmap, 
         color = colorRampPalette(c("navy", "white", "firebrick3"))(50), 
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         scale = "row", # Optional: scales rows to have zero mean and unit variance
         cluster_rows = TRUE,  # To cluster rows based on similarity
         cluster_cols = FALSE, # Disable column clustering to preserve 'pCR' and 'RD' order
         show_rownames = TRUE, 
         show_colnames = TRUE, 
         legend = TRUE)

```




```{r}
library(glmnet)
library(dplyr)
library(caret)
library(pls)

#PCA plot before feature selection performance
library(ggrepel)
library(dplyr)

train_data_TFEC <- read.csv(file = 'oversampled_data_TFEC_train.csv', row.names = 1)

# Loading the library
train_data_TFEC$Class <- as.factor(train_data_TFEC$Class)
nfolds = 10 # number of folds

x_primary = model.matrix(Class~., train_data_TFEC) # trim off the first column
                                         # leaving only the predictors
y_primary = train_data_TFEC %>%
  select(Class) %>%
  unlist() %>%
  as.numeric()


library(ncvreg)
#svg("lasso.coef_new.svg",width=10, height=10, pointsize=10)
lasso_mod = glmnet(x_primary, 
                   y_primary, 
                   alpha = 1,
                   nfolds =10)
# Fit lasso model on training data
bestlam = lasso_mod$lambda.min  # Select lamda that minimizes training MSE
bestlam


plot(lasso_mod)    # Draw plot of coefficients
cv.fit1 <- cv.ncvreg(
  X = x_primary, y = y_primary, penalty = "lasso")
summary(cv.fit1)
plot(cv.fit1)
## Within cv.fit is the fitted lasso model (fit)
## Within the fitted model is beta, a matrix of regression coefficients for each lambda
## We want only the column of beta corresponding to the lambda that minimizes CV RSME
all_coefs1 <- cv.fit1$fit$beta[,cv.fit1$fit$lambda == cv.fit1$lambda.min]
all_coefs1[all_coefs1 != 0]
write.csv(all_coefs1[all_coefs1 != 0], "lasso.coef.train_data.csv") 
```

```{r}
#VARSELRF
library(varSelRF)
library(randomForest)
?varSelRF

train_data_TFEC$Class <- as.factor(train_data_TFEC$Class)

x <- train_data_TFEC[, -which(names(train_data_TFEC) == "Class")]
Y <- train_data_TFEC$Class

set.seed(123) # For reproducibility

varSelRFOut <- varSelRF(x,Y , c.sd = 1, mtryFactor = 1, ntree = 5000,
         ntreeIterat = 2000, vars.drop.num = NULL, vars.drop.frac = 0.1,
         whole.range = TRUE, recompute.var.imp = FALSE, verbose = FALSE,
         returnFirstForest = TRUE, fitted.rf = NULL, keep.forest = FALSE)

# varSelRFOut will contain the results, including:
# - which variables were selected
# - the importance of each variable
# - the OOB error rate at each step of the selection process

# To see the selected variable names
print(varSelRFOut$selectedVars)

# To plot the OOB error rate as variables are eliminated
plot(varSelRFOut)

varSelRFOut$firstForest

```

```{r}
# Load necessary libraries
library(ggplot2)

# Assuming 'data' is your dataframe and it contains 'MMR_status' column
# Let's first remove the MMR_status column to perform PCA on just the molecular features
train_data_based_on_pheatmap <- read.csv(file = 'train_data_based_on_pheatmap.csv', row.names = 1)

train_data_based_on_pheatmap$Class <- as.factor(train_data_based_on_pheatmap$Class)

features <- train_data_based_on_pheatmap[, -which(names(train_data_based_on_pheatmap) == "Class")]

# Perform PCA
pca_result <- prcomp(features, center = TRUE, scale. = TRUE)

# Summarize PCA results
summary(pca_result)

# Plot PCA results
# First, prepare a dataframe that includes principal components and the MMR status
pca_data <- as.data.frame(pca_result$x)
pca_data$Class <- train_data_based_on_pheatmap$Class

# Use ggplot to visualize the first two principal components
ggplot(pca_data, aes(x = PC1, y = PC2, color = Class)) +
  geom_point() +
  theme_minimal() +
  labs(title = "PCA of pCR and RD Samples",
       x = "Principal Component 1",
       y = "Principal Component 2",
       color = "Class")

# Optionally, explore loadings to see which features contribute most to the principal components
loadings <- pca_result$rotation

library(mixOmics)

# Assuming 'data' has samples as rows and features as columns, and 'MMR_status' as a factor
plsda_result <- plsda(features, train_data_based_on_pheatmap$Class)

# Plot the results
plotIndiv(plsda_result, ind.names = FALSE, legend = TRUE, title = 'PLS-DA on pCR vs. RD')

```


```{r}
library(glmnet)
library(dplyr)
library(caret)
library(pls)

train_data_based_on_pheatmap <- read.csv(file = 'train_data_based_on_pheatmap.csv', row.names = 1)

train_data_based_on_pheatmap$Class <- as.factor(train_data_based_on_pheatmap$Class)
nfolds = 10 # number of folds

x_primary1 = model.matrix(Class~., train_data_based_on_pheatmap) # trim off the first column
                                         # leaving only the predictors
y_primary1 = train_data_based_on_pheatmap %>%
  select(Class) %>%
  unlist() %>%
  as.numeric()


library(ncvreg)
#svg("lasso.coef_new.svg",width=10, height=10, pointsize=10)
lasso_mod2 = glmnet(x_primary1, 
                   y_primary1, 
                   alpha = 1,
                   nfolds =10)

# Fit lasso model on training data
bestlam2 = lasso_mod2$lambda.min  # Select lamda that minimizes training MSE
bestlam2


plot(lasso_mod2)    # Draw plot of coefficients
cv.fit2 <- cv.ncvreg(
  X = x_primary1, y = y_primary1, penalty = "lasso")
summary(cv.fit2)
plot(cv.fit2)
## Within cv.fit is the fitted lasso model (fit)
## Within the fitted model is beta, a matrix of regression coefficients for each lambda
## We want only the column of beta corresponding to the lambda that minimizes CV RSME
all_coefs2 <- cv.fit2$fit$beta[,cv.fit2$fit$lambda == cv.fit2$lambda.min]
all_coefs2[all_coefs2 != 0]
write.csv(all_coefs2[all_coefs2 != 0], "lasso.coef.train_data1.csv") 
```
```{r}
#VARSELRF
library(varSelRF)
library(randomForest)


train_data_based_on_pheatmap$Class <- as.factor(train_data_based_on_pheatmap$Class)

x5 <- train_data_based_on_pheatmap[, -which(names(train_data_based_on_pheatmap) == "Class")]
Y5 <- train_data_based_on_pheatmap$Class

set.seed(123) # For reproducibility

varSelRFOut5 <- varSelRF(x5,Y5 , c.sd = 1, mtryFactor = 1, ntree = 5000,
         ntreeIterat = 2000, vars.drop.num = NULL, vars.drop.frac = 0.1,
         whole.range = TRUE, recompute.var.imp = FALSE, verbose = FALSE,
         returnFirstForest = TRUE, fitted.rf = NULL, keep.forest = FALSE)

# varSelRFOut will contain the results, including:
# - which variables were selected
# - the importance of each variable
# - the OOB error rate at each step of the selection process

# To see the selected variable names
print(varSelRFOut5$selectedVars)

# To plot the OOB error rate as variables are eliminated
plot(varSelRFOut5)

varSelRFOut5$firstForest

varSelRF(x5,Y5)


```

```{r}
# Load necessary library
library(pheatmap)


# Load the heatmap data
data_pheatmap_validation <- read.csv(file = 'validation_pheatmap_data.csv', row.names = 1)
clinical_data_pheatmap_validation <- read.csv(file = 'clinical_validation_pheatmap.csv', row.names = 1)

# Load clinical data for annotations
clinical_data_pheatmap_validation$Class <- as.factor(clinical_data_pheatmap_validation$Class)

# This assumes that the samples in data_for_heatmap correspond to the rows in clinical_data
ordered_columns <- order(clinical_data_pheatmap_validation$Class)
ordered_data_for_heatmap <- data_pheatmap_validation[, rownames(clinical_data_pheatmap_validation)[ordered_columns]]

# Prepare annotation data for columns based on the new order
annotation_col <- data.frame(Class = clinical_data_pheatmap_validation$Class[ordered_columns])
rownames(annotation_col) <- rownames(clinical_data_pheatmap_validation)[ordered_columns]

# Generate a color palette for the annotation
annotation_colors <- list(Class = c(pCR = "blue", RD = "red"))

# Create the heatmap with ordered data and annotation
pheatmap(ordered_data_for_heatmap, 
         color = colorRampPalette(c("navy", "white", "firebrick3"))(50), 
         annotation_col = annotation_col,
         annotation_colors = annotation_colors,
         scale = "row", # Optional: scales rows to have zero mean and unit variance
         cluster_rows = TRUE,  # To cluster rows based on similarity
         cluster_cols = FALSE, # Disable column clustering to preserve 'pCR' and 'RD' order
         show_rownames = TRUE, 
         show_colnames = TRUE, 
         legend = TRUE)

```
```{r}
# Load necessary libraries
library(ggplot2)

# Assuming 'data' is your dataframe and it contains 'MMR_status' column
# Let's first remove the MMR_status column to perform PCA on just the molecular features
validation_data_based_on_pheatmap <- read.csv(file = 'oversampled_data_TFEC_validation.csv', row.names = 1)

validation_data_based_on_pheatmap$Class <- as.factor(validation_data_based_on_pheatmap$Class)

features <- validation_data_based_on_pheatmap[, -which(names(validation_data_based_on_pheatmap) == "Class")]

# Perform PCA
pca_result <- prcomp(features, center = TRUE, scale. = TRUE)

# Summarize PCA results
summary(pca_result)

# Plot PCA results

library(mixOmics)

# Assuming 'data' has samples as rows and features as columns, and 'MMR_status' as a factor
plsda_result <- plsda(features, validation_data_based_on_pheatmap$Class)

# Plot the results
plotIndiv(plsda_result, ind.names = FALSE, legend = TRUE, title = 'PLS-DA on pCR vs. RD')

```

```{r}
# Run algorithms using 10-fold cross validation

library(randomForest)
library(randomForest)
library(prediction)
library(ROCR)
library(pROC)
require(party)
library(dplyr)
library(ggplot2)
library(caret)
library(varImp)
# Run algorithms using 10-fold cross validation

train_data <- read.csv(file = 'oversampled_data_TFEC_train.csv', row.names = 1)

test_data_TFAC <- read.csv(file = 'oversampled_data_TFEC_validation.csv', row.names = 1)

train_data$Class <- as.factor(train_data$Class)
test_data_TFAC$Class <- as.factor(test_data_TFAC$Class)



# Run algorithms using 10-fold cross validation
control <- trainControl(method="cv", number=10)
metric <- "Accuracy"

library(randomForest)
library(randomForest)
library(prediction)
library(ROCR)
library(pROC)
require(party)
library(dplyr)
library(ggplot2)
library(caret)
library(varImp)


#rf-other method
x.cf_rf_lasso_weka <- randomForest(Class~ ., data=na.omit(train_data), cross=10)
p1.x.cf1_rf_lasso_weka <- predict(x.cf_rf_lasso_weka, na.omit(train_data))
confusionMatrix(p1.x.cf1_rf_lasso_weka, na.omit(train_data$Class))
preds.x.cf_rf_lasso_weka_train <- prediction(as.numeric(p1.x.cf1_rf_lasso_weka), na.omit(train_data$Class))
perf.x.cf_rf_lasso_weka_train <- performance(preds.x.cf_rf_lasso_weka_train,"tpr","fpr")

p2.x.pred_rf_lasso_weka <- predict(x.cf_rf_lasso_weka, na.omit(test_data_TFAC), type = "response")
confusionMatrix(p2.x.pred_rf_lasso_weka, na.omit(test_data_TFAC$Class))
preds.x.cf_rf_lasso_weka <- prediction(as.numeric(p2.x.pred_rf_lasso_weka), na.omit(test_data_TFAC$Class))
perf.x.cf_rf_lasso_weka_test <- performance(preds.x.cf_rf_lasso_weka,"tpr","fpr")
performance(preds.x.cf_rf_lasso_weka,"auc")@y.values


#SVM
library(caret)
require(e1071)
x.cf_svm_lasso_weka <- svm(Class~., data = na.omit(train_data),type="C-classification",kernel="radial", trControl=control)
p1.x.cf1_svm_lasso_weka <- predict(x.cf_svm_lasso_weka, na.omit(train_data), type="prob")
confusionMatrix(p1.x.cf1_svm_lasso_weka, na.omit(train_data$Class))
preds.x.cf_svm_lasso_weka_train <- prediction(as.numeric(p1.x.cf1_svm_lasso_weka), na.omit(train_data$Class))
perf.x.cf_svm_lasso_weka_train <- performance(preds.x.cf_svm_lasso_weka_train,"tpr","fpr")

p2.x.pred_svm_lasso_weka <- predict(x.cf_svm_lasso_weka,  na.omit(test_data_TFAC), type="prob")
confusionMatrix(p2.x.pred_svm_lasso_weka, na.omit(test_data_TFAC$Class))
preds.x.cf_svm_lasso_weka <- prediction(as.numeric(p2.x.pred_svm_lasso_weka), na.omit(test_data_TFAC$Class))
perf.x.cf_svm_lasso_weka <- performance(preds.x.cf_svm_lasso_weka,"tpr","fpr")
performance(preds.x.cf_svm_lasso_weka,"auc")@y.values


#KNN
trControl2 <- trainControl(method = "repeatedcv",
                          number = 10,
                          repeats = 3)

x.cf_knn_lasso_weka <- train(Class~., data=na.omit(train_data), method="knn", trControl=trControl2)
p1.x.cf1_knn_lasso_weka <- predict(x.cf_knn_lasso_weka, na.omit(train_data), type="raw")
confusionMatrix(p1.x.cf1_knn_lasso_weka, train_data$Class)
preds.x.cf_knn_lasso_weka_train <- prediction(as.numeric(p1.x.cf1_knn_lasso_weka), na.omit(train_data$Class))
perf.x.cf_knn_lasso_weka_train <- performance(preds.x.cf_knn_lasso_weka_train,"tpr","fpr")

p2.x.pred_knn_lasso_weka <- predict(x.cf_knn_lasso_weka,  na.omit(test_data_TFAC), type="raw")
confusionMatrix(p2.x.pred_knn_lasso_weka, na.omit(test_data_TFAC$Class))
preds.x.cf_knn_lasso_weka <- prediction(as.numeric(p2.x.pred_knn_lasso_weka), na.omit(test_data_TFAC$Class))
perf.knn<- performance(preds.x.cf_knn_lasso_weka,"tpr","fpr")
performance(preds.x.cf_knn_lasso_weka,"auc")@y.values
```

```{r}
library(pROC)

#rf_train
plot(perf.x.cf_rf_lasso_weka_train, main = "ROC Curve for RF, SVM, and KNN TFEC Train Model", col=4, lwd =2)
grid()
legend(0.6, 0.6, c('RF', 'SVM', 'KNN'), 4:6)
legend("bottomright", legend = paste("AUC_RF =", round(performance(preds.x.cf_rf_lasso_weka_train, "auc")@y.values[[1]], 2), "AUC_SVM =", round(performance(preds.x.cf_svm_lasso_weka_train, "auc")@y.values[[1]], 2), "AUC_KNN =", round(performance(preds.x.cf_knn_lasso_weka_train, "auc")@y.values[[1]], 2))) 

#SVM_train
plot(perf.x.cf_svm_lasso_weka_train, col=5, lwd =2, add = TRUE)

#KNN_train
plot(perf.x.cf_knn_lasso_weka_train, col=6, lwd =2, add = TRUE)


#rf_test

plot(perf.x.cf_rf_lasso_weka_test, main = "ROC Curve for RF, SVM, and KNN TFEC test Model", col=4, lwd =2)
grid()
legend(0.6, 0.6, c('RF', 'SVM', 'KNN'), 4:6)
legend("bottomright", legend = paste("AUC_RF =", round(performance(preds.x.cf_rf_lasso_weka, "auc")@y.values[[1]], 2), "AUC_SVM =", round(performance(preds.x.cf_svm_lasso_weka, "auc")@y.values[[1]], 2), "AUC_KNN =", round(performance(preds.x.cf_knn_lasso_weka, "auc")@y.values[[1]], 2))) 

#svm_test
plot(perf.x.cf_svm_lasso_weka, col=5, lwd =2, add = TRUE)

#knn_test
plot(perf.knn, col=6, lwd =2, add = TRUE)
```


```{r}
# Load necessary libraries
library(ggplot2)

# Assuming 'data' is your dataframe and it contains 'MMR_status' column
# Let's first remove the MMR_status column to perform PCA on just the molecular features
train_data_tfec <- read.csv(file = 'oversampled_data_TFEC_train.csv', row.names = 1)

train_data_tfec$Class <- as.factor(train_data_tfec$Class)

features1 <- train_data_tfec[, -which(names(train_data_tfec) == "Class")]



library(mixOmics)

# Assuming 'data' has samples as rows and features as columns, and 'MMR_status' as a factor
plsda_result1 <- plsda(features1, train_data_tfec$Class)

# Plot the results
plotIndiv(plsda_result1, ind.names = FALSE, legend = TRUE, title = 'PCA//TFEC Training set')
```


```{r}
library(multcompView)

train_TFEC_data <- read.csv(file = 'oversampled_data_TFEC_train.csv', row.names = 1)
wilcox.test(train_data_based_on_pheatmap$USP7 ~ Class, data = train_data_based_on_pheatmap)
pairwise.wilcox.test(train_data_based_on_pheatmap$USP7, train_data_based_on_pheatmap$Class)

library(ggpubr)
library(ggplot2)

p <- ggboxplot(train_data_based_on_pheatmap, x = "Class", y = "USP7", palette = "jco", add = "jitter") +  labs(x="T/FEC RESPONSE", y="USP7 Gene") + geom_boxplot(aes(fill = Class), show.legend = TRUE)
#  Add p-value
p + stat_compare_means()
# Change method
p + stat_compare_means(method = "wilcox.test")



#Test
test_data_TFEC <- read.csv(file = 'oversampled_data_TFEC_96 - Copy.csv', row.names = 1)
wilcox.test(test_data_TFEC$USP7 ~ Class, data = test_data_TFEC)
pairwise.wilcox.test(test_data_TFEC$USP7, test_data_TFEC$Class)

library(ggpubr)
library(ggplot2)

p1 <- ggboxplot(test_data_TFEC, x = "Class", y = "USP7", palette = "jco", add = "jitter") +  labs(x="T/FEC RESPONSE", y="USP7 Gene") + geom_boxplot(aes(fill = Class), show.legend = TRUE)
#  Add p-value
p1 + stat_compare_means()
# Change method
p1 + stat_compare_means(method = "wilcox.test")

```

```{r}
library(multcompView)
  
wilcox.test(train_TFEC_data$MFAP1 ~ Class, data = train_TFEC_data)
pairwise.wilcox.test(train_TFEC_data$MFAP1, train_TFEC_data$Class)

library(ggpubr)
library(ggplot2)

p <- ggboxplot(train_TFEC_data, x = "Class", y = "MFAP1", palette = "jco", add = "jitter") +  labs(x="T/FEC RESPONSE", y="MFAP1 Gene") + geom_boxplot(aes(fill = Class), show.legend = TRUE)
#  Add p-value
p + stat_compare_means()
# Change method
p + stat_compare_means(method = "wilcox.test")



test_data_TFEC <- read.csv(file = 'oversampled_data_TFEC_96 - Copy.csv', row.names = 1)
wilcox.test(test_data_TFEC$MFAP1 ~ Class, data = test_data_TFEC)
pairwise.wilcox.test(test_data_TFEC$MFAP1, test_data_TFEC$Class)

p1 <- ggboxplot(test_data_TFEC, x = "Class", y = "MFAP1", palette = "jco", add = "jitter") +  labs(x="T/FEC RESPONSE", y="MFAP1 Gene") + geom_boxplot(aes(fill = Class), show.legend = TRUE)
#  Add p-value
p1 + stat_compare_means()
# Change method
p1 + stat_compare_means(method = "wilcox.test")


```


```{r}
#BiocManager::install("clusterProfiler")
#BiocManager::install("org.Hs.eg.db")

#BiocManager::install() # Updates all installed Bioconductor packages
#update.packages(ask = FALSE) # Updates all installed CRAN packages

library(KEGGREST)
library(org.Hs.eg.db)
library(clusterProfiler)



data_DEGS_TFEC <- read.csv(file = 'results_output_TFEC_all_genes.csv')

# Assuming gene identifiers are in the first column. Replace `V1`with the actual column name if different.
gene_symbols  <- data_DEGS_TFEC[,1]

# Convert gene symbols to Entrez IDs (adjust OrgDb if using a different organism)
entrez_ids <- bitr(gene_symbols, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)


# Perform GO enrichment analysis
ego <- enrichGO(gene         = entrez_ids$ENTREZID,
                OrgDb        = org.Hs.eg.db,
                ont          = "CC", # Use "CC" or "MF" for Cellular Component or Molecular Function
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.05,
                qvalueCutoff  = 0.2,
                readable      = TRUE) # Set to FALSE if you want to keep original Entrez IDs


# View the results
summary <- print(summary(ego))

write.csv(summary, "summary.CC.GO.csv") 

# Visualize the results: dotplot
dotplot(ego) + ggplot2::ggtitle("GO - CC Enrichment Analysis")

# Alternatively, use barplot or enrichMap for visualization
barplot(ego)
```


```{r}
library(clusterProfiler)
library(org.Hs.eg.db) # Assuming you're working with human genes

# Example Entrez IDs
data_DEGS_TFEC <- read.csv(file = 'DEGs_Filter.csv')

# Assuming gene identifiers are in the first column. Replace `V1`with the actual column name if different.
gene_symbols  <- data_DEGS_TFEC[,1]

# Convert gene symbols to Entrez IDs (adjust OrgDb if using a different organism)
entrez_ids <- bitr(gene_symbols, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)

ego_BP <- enrichGO(gene         = entrez_ids$ENTREZID,
                OrgDb        = org.Hs.eg.db,
                ont          = "BP", # Use "CC" or "MF" for Cellular Component or Molecular Function
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.05,
                qvalueCutoff  = 0.2,
                readable      = TRUE) # Set to FALSE if you want to keep original Entrez IDs


ego_CC <- enrichGO(gene         = entrez_ids$ENTREZID,
                OrgDb        = org.Hs.eg.db,
                ont          = "CC", # Use "CC" or "MF" for Cellular Component or Molecular Function
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.05,
                qvalueCutoff  = 0.2,
                readable      = TRUE) # Set to FALSE if you want to keep original Entrez IDs

ego_MF <- enrichGO(gene         = entrez_ids$ENTREZID,
                OrgDb        = org.Hs.eg.db,
                ont          = "MF", # Use "CC" or "MF" for Cellular Component or Molecular Function
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.05,
                qvalueCutoff  = 0.2 ,
                readable      = TRUE) # Set to FALSE if you want to keep original Entrez IDs



# Visualize the results: dotplot
dotplot(ego_MF) + ggplot2::ggtitle("GO - MF - TFEC")

# Alternatively, use barplot or enrichMap for visualization
barplot(ego_BP)

```

```{r}
library("clusterProfiler")
library("enrichplot")
library(org.Hs.eg.db) # Assuming you're working with human genes
library("ggplot2")

#Load data

# Example Entrez IDs
data_DEGS_TFEC <- read.csv(file = 'results_output_TFEC_all_genes.csv')

# Assuming gene identifiers are in the first column. Replace `V1`with the actual column name if different.
gene_symbols  <- data_DEGS_TFEC[,1]

#Define significance threshold

up.idx <- which(data_DEGS_TFEC$adj.P.Val < 0.05 & data_DEGS_TFEC$logFC > 0) # FDR < 0.05 and logFC > 0
dn.idx <- which(data_DEGS_TFEC$adj.P.Val < 0.05 & data_DEGS_TFEC$logFC < 0) # FDR < 0.05 and logFC < 0

length(up.idx)
length(dn.idx)

up.genes <- data_DEGS_TFEC[up.idx,]$Gene
dn.genes <- data_DEGS_TFEC[dn.idx,]$Gene

ontology <- "BP"
outTitle <- paste0("clusterProfiler_GO-", ontology, "_ORA_simplify")
outTitle

all.genes <- data_DEGS_TFEC$Gene
all.genes.df <- bitr(gene_symbols, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)
head(all.genes.df, 10)


up.genes.df<-bitr(up.genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")
dn.genes.df<-bitr(dn.genes, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db")

upEGO = enrichGO(gene = up.genes.df$ENTREZID, universe = all.genes.df$ENTREZID, 
         OrgDb = "org.Hs.eg.db", ont = ontology, pvalueCutoff = 0.05, 
         pAdjustMethod = "BH", qvalueCutoff = 0.05, readable = TRUE)
upEGO


dnEGO = enrichGO(gene = dn.genes.df$ENTREZID, universe = all.genes.df$ENTREZID,
                 OrgDb = "org.Hs.eg.db", ont = ontology, pvalueCutoff = 0.05,
                 pAdjustMethod = "BH", qvalueCutoff = 0.05, readable = TRUE)
dnEGO


#barplot(upEGO, showCategory = 10) + 
    #ggtitle(paste0("GO-", ontology," ORA of up-regulated genes")) + 
    #xlab("Enriched terms") + ylab("Count")


#barplot(dnEGO, showCategory = 20) + 
    #ggtitle(paste0("GO-", ontology," ORA of down-regulated genes")) +
        #xlab("Enriched terms") + ylab("Count")

```


```{r}
kegg_gene_list <- data_DEGS_TFEC$log2FC
names(kegg_gene_list) <- all.genes.df
kegg_gene_list = sort(kegg_gene_list, decreasing = TRUE)
kegg_sig_genes_df = subset(data_DEGS_TFEC, adj.P.Val < 0.05)
kegg_genes <- kegg_sig_genes_df$log2FC
names(kegg_genes) <- kegg_sig_genes_df$Gene
kegg_genes <- names(kegg_genes)[abs(kegg_genes) > 2]


library("clusterProfiler")

enrichKEGG <- function(gene,
                       organism          = "hsa",
                       keyType           = "kegg",
                       pvalueCutoff      = 0.05,
                       pAdjustMethod     = "BH",
                       universe,
                       minGSSize         = 10,
                       maxGSSize         = 500,
                       qvalueCutoff      = 0.2,
                       use_internal_data = FALSE) {

    if (inherits(organism, "character")) {           
        if (organism == "cpd") {
            organism = gson_cpd()
        }
    }

    if (inherits(organism, "character")) {           
        species <- organismMapper(organism)
        if (use_internal_data) {
            KEGG_DATA <- get_data_from_KEGG_db(species)
        } else {
            KEGG_DATA <- prepare_KEGG(species, "KEGG", keyType)
        }
    } else if (inherits(organism, "GSON")) {
        KEGG_DATA <- organism
        species <- KEGG_DATA@species
        keyType <- KEGG_DATA@keytype
    } else {
        stop("organism should be a species name or a GSON object")
    }
res <- enricher_internal(gene,
                             pvalueCutoff  = pvalueCutoff,
                             pAdjustMethod = pAdjustMethod,
                             universe      = universe,
                             minGSSize     = minGSSize,
                             maxGSSize     = maxGSSize,
                             qvalueCutoff  = qvalueCutoff,
                             USER_DATA = KEGG_DATA)
    if (is.null(res))
        return(res)

    res@ontology <- "KEGG"
    res@organism <- species
    res@keytype <- keyType

    res <- append_kegg_category(res)
    return(res)
}
get_KEGG_Env <- function() {
    if (! exists(".KEGG_clusterProfiler_Env", envir = .GlobalEnv)) {
        pos <- 1
        envir <- as.environment(pos)
        assign(".KEGG_clusterProfiler_Env", new.env(), envir=envir)
    }
    get(".KEGG_clusterProfiler_Env", envir = .GlobalEnv)
}

download_KEGG <- function(species, keggType="KEGG", keyType="kegg") {
    KEGG_Env <- get_KEGG_Env()

    use_cached <- FALSE

    if (exists("organism", envir = KEGG_Env, inherits = FALSE) &&
        exists("_type_", envir = KEGG_Env, inherits = FALSE) ) {

        org <- get("organism", envir=KEGG_Env)
        type <- get("_type_", envir=KEGG_Env)

        if (org == species && type == keggType &&
            exists("KEGGPATHID2NAME", envir=KEGG_Env, inherits = FALSE) &&
            exists("KEGGPATHID2EXTID", envir=KEGG_Env, inherits = FALSE)) {

            use_cached <- TRUE
        }
    }

    if (use_cached) {
        KEGGPATHID2EXTID <- get("KEGGPATHID2EXTID", envir=KEGG_Env)
        KEGGPATHID2NAME <- get("KEGGPATHID2NAME", envir=KEGG_Env)
    } else {
        if (keggType == "KEGG") {
            kres <- download.KEGG.Path(species)
        } else {
            kres <- download.KEGG.Module(species)
        }

        KEGGPATHID2EXTID <- kres$KEGGPATHID2EXTID
        KEGGPATHID2NAME <- kres$KEGGPATHID2NAME

        assign("organism", species, envir=KEGG_Env)
        assign("_type_", keggType, envir=KEGG_Env)
        assign("KEGGPATHID2NAME", KEGGPATHID2NAME, envir=KEGG_Env)
        assign("KEGGPATHID2EXTID", KEGGPATHID2EXTID, envir=KEGG_Env)
    }

    if (keyType != "kegg") {
        need_idconv <- FALSE
        idconv <- NULL
        if (use_cached &&
            exists("key", envir=KEGG_Env, inherits = FALSE) &&
            exists("idconv", envir=KEGG_Env, inherits = FALSE)) {

            key <- get("key", envir=KEGG_Env)
            if (key == keyType) {
                idconv <- get("idconv", envir=KEGG_Env)
            } else {
                need_idconv <- TRUE
            }
        } else {
            neec_idconv <- TRUE
        }

        if (need_idconv || is.null(idconv)) {
            idconv <- KEGG_convert("kegg", keyType, species)
            assign("key", keyType, envir=KEGG_Env)
            assign("idconv", idconv, envir=KEGG_Env)
        }
        colnames(KEGGPATHID2EXTID) <- c("from", "kegg")
        KEGGPATHID2EXTID <- merge(KEGGPATHID2EXTID, idconv, by.x='kegg', by.y='from')
        KEGGPATHID2EXTID <- unique(KEGGPATHID2EXTID[, -1])
    }

    return(list(KEGGPATHID2EXTID = KEGGPATHID2EXTID,
                KEGGPATHID2NAME  = KEGGPATHID2NAME))
}

prepare_KEGG <- function(species, KEGG_Type="KEGG", keyType="kegg") {
    kegg <- download_KEGG(species, KEGG_Type, keyType)
    build_Anno(kegg$KEGGPATHID2EXTID,
               kegg$KEGGPATHID2NAME)
}

download.KEGG.Path <- function(species) {
    keggpathid2extid.df <- kegg_link(species, "pathway")
    if (is.null(keggpathid2extid.df)) {
        message <- paste("Failed to download KEGG data.",
                         "Wrong 'species' or the network is unreachable.",
                         "The 'species' should be one of organisms listed in",
                         "'https://www.genome.jp/kegg/catalog/org_list.html'")
        stop(message)
    }

    keggpathid2extid.df[,1] %<>% gsub("[^:]+:", "", .)
    keggpathid2extid.df[,2] %<>% gsub("[^:]+:", "", .)

    keggpathid2name.df <- kegg_list("pathway", species)

    keggpathid2name.df[,2] <- sub("\\s-\\s[a-zA-Z ]+\\(\\w+\\)$", "", keggpathid2name.df[,2])
    # keggpathid2name.df[,1] %<>% gsub("path:map", species, .)

    ## if 'species="ko"', ko and map path are duplicated, only keep ko path.
    ##
    ## https://www.kegg.jp/dbget-bin/www_bget?ko+ko00010
    ## https://www.kegg.jp/dbget-bin/www_bget?ko+map0001
    ##
    keggpathid2extid.df <- keggpathid2extid.df[keggpathid2extid.df[,1] %in% keggpathid2name.df[,1],]

    return(list(KEGGPATHID2EXTID=keggpathid2extid.df,
                KEGGPATHID2NAME=keggpathid2name.df))
}

download.KEGG.Module <- function(species) {
    keggmodule2extid.df <- kegg_link(species, "module")
    if (is.null(keggmodule2extid.df)) {
        message <- paste("Failed to download KEGG data.",
                         "Wrong 'species' or the network is unreachable.",
                         "The 'species' should be one of organisms listed in",
                         "'https://www.genome.jp/kegg/catalog/org_list.html'")
        stop(message)
    }

    keggmodule2extid.df[,1] %<>% gsub("[^:]+:", "", .) %>% gsub(species, "", .) %>% gsub("^_", "", .)
    keggmodule2extid.df[,2] %<>% gsub("[^:]+:", "", .)

    keggmodule2name.df <- kegg_list("module")
    # now module do not nedd sub 'md:'
    # keggmodule2name.df[,1] %<>% gsub("md:", "", .)
    return(list(KEGGPATHID2EXTID=keggmodule2extid.df,
                KEGGPATHID2NAME =keggmodule2name.df))
}


##' viewKEGG function is for visualize KEGG pathways
##' works with enrichResult object to visualize enriched KEGG pathway
##'
##'
##' @param obj enrichResult object
##' @param pathwayID pathway ID or index
##' @param foldChange fold change values
##' @param color.low color of low foldChange genes
##' @param color.high color of high foldChange genes
##' @param kegg.native logical
##' @param out.suffix suffix of output file
## @importFrom pathview pathview
## @importFrom pathview kegg.species.code
##' @importFrom utils citation
##' @references Luo et al. (2013) Pathview: an R/Bioconductor package for
##'pathway-based data integration and visualization. \emph{Bioinformatics} (Oxford,
##'England), 29:14 1830--1831, 2013. ISSN 1367-4803
##'\url{http://bioinformatics.oxfordjournals.org/content/abstract/29/14/1830.abstract}
##'PMID: 23740750
##' @noRd
viewKEGG <- function(obj, pathwayID, foldChange,
                       color.low="green",
                       color.high="red",
                       kegg.native=TRUE,
                       out.suffix="clusterProfiler") {

    if (!inherits(obj, "enrichResult"))
        stop("only enrichResult object supported.")
    if (obj@ontology != "KEGG")
        stop("only KEGG supported.")

    print("viewKEGG is a wrapper function of pathview")
    citation("pathview")

    pkg <- "pathview"
    suppressMessages(require(pkg, character.only=TRUE))
    if (is.numeric(pathwayID)) {
        pathwayID <- as.data.frame(obj)[pathwayID, 1]
    }
    if (length(pathwayID) == 1 & pathwayID == "all") {
        pathwayID <- as.data.frame(obj)[, 1]
    }
    m.fc <- max(abs(foldChange))
    bins <- ceiling(m.fc) * 2
    if (bins < 10)
        bins <- 10
    pathview <- eval(parse(text=pkg))
    res <- lapply(pathwayID, function(pid) {
        pathview(gene.data=foldChange,
                 pathway.id = pid,
                 species = "hsa",
                 limit = list(gene=m.fc, cpd=1),
                 bins = list(gene=bins, cpd=10),
                 low = list(gene=color.low, cpd="blue"),
                 high = list(gene=color.high, cpd="yellow"),
                 kegg.native=kegg.native,
                 out.suffix=out.suffix,
                 new.signature=FALSE)
    })
    return (res)
}

##' @importFrom AnnotationDbi as.list
##' @importFrom utils stack
get_data_from_KEGG_db <- function(species) {
    PATHID2EXTID <- as.list(get_KEGG_db("KEGGPATHID2EXTID"))
    if (!any(grepl(species, names(PATHID2EXTID)))) {
        stop("input species is not supported by KEGG.db...")
    }
    idx <- grep(species, names(PATHID2EXTID))
    PATHID2EXTID <- PATHID2EXTID[idx]
    PATHID2EXTID.df <- stack(PATHID2EXTID)
    PATHID2EXTID.df <- PATHID2EXTID.df[, c(2,1)]
    PATHID2NAME <- as.list(get_KEGG_db("KEGGPATHID2NAME"))
    PATHID2NAME.df <- data.frame(path=names(PATHID2NAME),
                                 name=unlist(PATHID2NAME))
    build_Anno(PATHID2EXTID.df, PATHID2NAME.df)
}

get_KEGG_db <- function(kw) {
    annoDb <- "KEGG.db"
    suppressMessages(requireNamespace(annoDb))
    eval(parse(text=paste0(annoDb, "::", kw)))
}

organismMapper <- function(organism) {
    ## it only map those previous supported organism

    if (organism == "anopheles") {
        species <- "aga"
    } else if (organism == "arabidopsis") {
        species <- "ath"
    } else if (organism == "bovine") {
        species <- "bta"
    } else if (organism == "canine") {
        species <- "cfa"
    } else if (organism == "chicken") {
        species <- "gga"
    } else if (organism == "chipm") {
        species <- "ptr"
    } else if (organism == "ecolik12") {
        species <- "eco"
    } else if (organism == "ecsakai") {
        species <- "ecs"
    } else if (organism == "fly") {
        species <- "dme"
    } else if (organism == "human") {
        species <- "hsa"
    } else if (organism == "malaria") {
        species <- "pfa"
    } else if (organism == "mouse") {
        species <- "mmu"
    } else if (organism == "pig") {
        species <- "ssc"
    } else if (organism == "rat") {
        species <- "rno"
    } else if (organism == "rhesus") {
        species <- "mcc"
    } else if (organism == "worm" || organism == "celegans") {
        species <- "cel"
    } else if (organism == "xenopus") {
        species <- "xla"
    } else if (organism == "yeast") {
        species <- "sce"
    } else if (organism == "zebrafish") {
        species <- "dre"
    } else {
        species <- organism
    }
    return(species)
}

R.utils::setOption("clusterProfiler.download.method","wget")

kegg_organism = "hsa"
kk <- enrichKEGG(gene=kegg_genes, universe=names(kegg_gene_list),organism=kegg_organism, pvalueCutoff = 0.05, keyType = "ncbi-geneid")

dotplot(kk, 
        showCategory = 10, 
        title = "Enriched Pathways",
        font.size = 8)
```












